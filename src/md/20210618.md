## Answers to Problem Sets from JS: Hard Parts

Here is a review of the exercises and some of the concepts taught in the course [JS: The Hard Parts](#) on frontend masters. The questions were created by someone at Codesmith, and the answers are ones that I wrote. The originals are on the web here, at [csbin.io](https://csbin.io/async)
- [Async functions, callbacks, the callback queue](#async)
- [JS Scope, variable environments, and programming with closure](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/closure)
- [Promises, deferring, the microtask queue](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/promise)
- [Object prototypes, the class syntax](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/oop)

---

### Async

[The solutions on GitHub](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/async)

What are asynchronous functions? In Javascript, you have an asyncronous function when you invoke a function that makes a call to code that is defined outside of the current execution context. Before explaing any further, let's take a look at an example

```
function makeAnAsyncCall(message) {
  setTimeout(() => {
    console.log(message);
  }, 10000);
}

makeAnAsyncCall("This message is going to be logged out to the console in ten seconds, after all the code in the current execution context runs (even if it's more than ten seconds of code)");

// ten+ seconds of syncronous code
```
`makeAnAsyncCall` is calling a function `setTimeout` which is built into the JS environment. It's provided by the browser, or node. `setTimeout` is passed a function, and the integer 10000. Immediately upon `setTimeout` being called, the function passed into setTimeout is added to a queue that is being maintained in the JS engine. The integer 10000 that is passed into setTimeout is the amount of time the


---

#### Debounce

```
function debounce(callback, interval) {
  let timer,
    readyToCall = true;

  /**
   *
   * @returns callback(), or "undefined" depending on if interval ms have ellapsed since last call to debouncedFunction
   */
  function debouncedFunction() {
    if (readyToCall) {
      readyToCall = false;

      timer = setTimeout(() => {
        readyToCall = true;
      }, interval);

      return callback();
    } else {
      // when debouncedFunction is not ready to be called,the timer running from the previous call should be resetâ€”making it "debouced three seconds from every call", instead of "debounded three seconds from every successful call"
      clearTimeout(timer);

      timer = setTimeout(() => {
        readyToCall = true;
      }, interval);

      return "unsucessful";
    }
  }

  return debouncedFunction;
}

function sayHi() {
  return "hi";
}

const debouncedSayHi = debounce(sayHi, 3000);

/* tests */

console.log(debouncedSayHi()); // -> 'hi'

setTimeout(() => {
  console.log(debouncedSayHi());
}, 2000); // -> undefined

setTimeout(() => {
  console.log(debouncedSayHi());
}, 4000); // -> undefined

setTimeout(() => {
  console.log(debouncedSayHi());
}, 8000); // -> 'hi'

// ?? using iterm to run file, there is a second pause in between when cb for last setTimeout? I would expect it to just cut out right there
```

