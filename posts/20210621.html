<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600&family=Squada+One&display=swap');
  </style>
  <link rel="stylesheet" href="./../style.css">
  <link rel="stylesheet" href="./../vendor/css/prism.css">

  <title>Answers to the async problem set from JS: The Hard Parts on Frontend Masters</title>
</head>

<body>
  <div class="post">

    <section class="hat">
      <!-- <a href="./../index.html">Return home</a> -->

    </section>
    <article class="text">
      <h2>Async problem set from JS The Hard Parts</h2>
      <p>If you haven't solved these questions yet, I recommend you take a minute to work each one out before reading
        my solutions. These were all written by somebody at Codesmith, and were used as the exercises for the class
        JavaScript: The Hard Parts, on Frontend Masters.</p>

      <hr>

      <section>
        <h3>debounce</h3>
        <p>Every time debouncedFx is called, if 2000 ms haven't ellapsed since the last time it was called, debouncedFx
          returns undefined. If 2000 ms or more have ellapsed since debouncedFx was last called, debouncedFx will call
          the
          function definition that was passed to the debounce function which generated debounceFx.</p>

        <pre>
        const debouncedFx = debounce(fx, 2000);
    
        function sayHi() {
          return "hi";
        }
    
        const debouncedSayHi = debounce(sayHi, 3000);
        
        console.log(debouncedSayHi());                              
        // -> 'hi'
        setTimeout(() => { console.log(debouncedSayHi()); }, 2000); 
        // -> undefined
        setTimeout(() => { console.log(debouncedSayHi()); }, 4000); // -> undefined
        setTimeout(() => { console.log(debouncedSayHi()); }, 8000); 
        // -> 'hi'
  
        function debounce(callback, interval) {
          let readyToCall = true;
          let timer = undefined;
    
          function debouncedFunction() => {
            if (readyToCall) {
              readyToCall = false;

              timer = setTimeout(() => {
                readyToCall = true;
              }, interval);

              return callback();
            } else {

              // clearTimeout, because there is still a timer running
              // from the last time debouncedFunction was called
              clearTimeout(timer);
    
              timer = setTimeout(() => {
                readyToCall = true;
              }, interval);
    
              return undefined;
            }
          };
    
          return debouncedFunction;
        }
     </pre>
      </section>
      <hr>
      <section>
        <p><strong>second clock class</strong></p>
        <pre>
      /*
        SecondClock class has two methods:
          start()
          reset()
      
        start():
          upon being called, calls this.cb on an argument every second
          the argument to this.cb is current seconds "value"
        
          the callback is invoked every second on the "seconds hand" of the clock. always start from 1 and dont utilize the seconds value of the current computer clock time
      
            the first "tick" with value 1 occurs 1 second after the initial secondClock is called
      
            the second "tick" with value 2 occurs 2 seconds after the initial secondClock is called
      
            ...
      
        reset():
          upon being called, stops the clock and resets time back to the beginning
      */

      const clock = new SecondClock((val) => {
        console.log(val);
      });

      console.log("Started Clock.");
      clock.start();

      setTimeout(() => {
        clock.reset();
        console.log("Stopped Clock after 6 seconds.");
      }, 6000);

      class SecondClock {
        constructor(cb) {
          this.cb = cb;
          this.secondsHand = 0;
          this.clock = undefined;
        }
        start() {
          this.clock = setInterval(() => {
            this.cb(++this.secondsHand);
          }, 1000);
        }
        reset() {
          clearInterval(this.clock);
        }
      }            
       </pre>
      </section>
      <hr>
      <section>
        <p><strong>promised</strong></p>
        <pre>
      const createPromise = promised("wait for it...");
      createPromise.then((val) => console.log(val));
      // will log "wait for it..." to the console after 2 seconds

      function promised(val) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve(val);
          }, 4000);
        });
      } 
       </pre>
      </section>
      <hr>
      <section>
        <p><strong>delay counter</strong></p>
        <pre>
      /*
        Write a function delayCounter that accepts a number (called 'target') as the first argument and a number of milliseconds (called 'wait') as the second argument, and returns a function.
        
        When the returned function is invoked, it should log to the console all of the numbers between 1 and the target number, spaced apart by 'wait' milliseconds.
      */
      
      const countLogger = delayCounter(3, 50);
      
      countLogger();
      // After 1 second, log 1
      // After 2 seconds, log 2
      // After 3 seconds, log 3
      
      function delayCounter(target, wait) {
        let counter = 1;
        function interval() {
          let intervalTimer = setInterval(() => {
            if (counter === target) {
              clearInterval(intervalTimer);
              console.log(counter);
              counter ++; 
            } else {
              console.log(counter);
              counter++;
            }
          }, wait);
        }
      
        return interval;
      } 
      </pre>
      </section>
      <hr>
      <section>
        <p><strong>every x seconds for y seconds</strong></p>
        <pre>
      function everyXsecsForYsecs(func, interval, duration) {
        let elapsed = 0;
        let clock = setInterval(() => {
          if (elapsed >= duration) {
            clearInterval(clock);
          }
          func();
          elapsed += interval;
        }, interval);
      }
      
      function theEnd() {
        console.log("This is the end!");
      }
      
      everyXsecsForYsecs(theEnd, 1000, 20000);
      // should call theEnd every 2 seconds, for 20 seconds
      
      </pre>
      </section>
      <hr>
      <section>
        <p><strong>limited repeat</strong></p>
        <pre>
      /*
      Create a function limitedRepeat that console logs hi for now every second, but only for 5 seconds.
      Research how to use clearInterval if you are not sure how to do this. 
      */
      
      limitedRepeat();
      
      function limitedRepeat() {
        let counter = 0;
        let clock = setInterval(() => {
          if (counter >= 4) {
            clearInterval(clock);
          }
          console.log("hi");
          counter++;
        }, 1000);
      }
      </pre>
      </section>
      <hr>
      <section>
        <p><strong>broken record</strong></p>
        <pre>
      /*
      Create a function brokenRecord that console logs hi again every second.
      Use the End Code button to stop the console logs when you are satisfied that it is working. 
      */
      brokenRecord();
      
      function brokenRecord() {
        setInterval(() => {
          console.log("hi");
        }, 1000);
      }
      
      </pre>
      </section>
      <hr>
      <section>
        <p><strong>delayed greet</strong></p>
        <pre>
      /*
      Create a function delayedGreet that console logs welcome after 3 seconds. 
      */
      delayedGreet();
      
      function delayedGreet() {
        setTimeout(() => {
          console.log("welcome");
        }, 3000);
      } 
      </pre>
      </section>
      <hr>
      <section>
        <p><strong>hello goodbye</strong></p>
        <pre>
          <code class="language-js">
/*
Create a function helloGoodbye that console logs hello right away, and good bye after 2 seconds.
*/
helloGoodbye();
function helloGoodbye() {
  console.log("Hello");
  setTimeout(() => {
    console.log("Gooooodbye");
  }, 2000);
}
        </code>
      </pre>
      </section>
      <hr>
      <section>
        <p><strong>thinking point</strong></p>
        <pre>
        <code class="language-js">            
/*
Thinking point (no writing code necessary for this challenge): Inspect the code given to you in Challenge 1. In what order should the console logs come out? Howdy first or Partnah first? 
*/
         
function sayHowdy() {
  console.log("Howdy");
}
         
function testMe() {
  setTimeout(sayHowdy, 0);
  console.log("Partnah");
}
         
testMe(); // what order should these log out? Howdy or Partnah first?
         
/* ANSWER
         
> Partnah
> Howdy
         
because setTimeout is put into the callback queue, it cannot execute it's code until all the code in the global call stack is run, because you cannot have asynchronous actions happening while synchronous code is being run, because that's just not how it works
*/
        </code>
      </pre>
      </section>
    </article>
  </div>

  <script src="./../vendor/js/prism.js"></script>
</body>

</html>