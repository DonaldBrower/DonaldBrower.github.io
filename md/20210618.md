## Solutions to Problem Sets from JS: Hard Parts

Problem sets to help you understand the different features of JS:

- [Async function execution, callbacks, the callback queue](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/async) — [examples](#async)
- [JS Scope, variable environments, and programming with closure](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/closure) — [examples](#)
- [Promises, deferring, the microtask queue](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/promise) — [examples](#)
- [Object prototypes, the class syntax](https://github.com/DonaldBrower/js-hardparts-solutions/tree/master/oop) — [examples](#)

The questions were created by someone at Codesmith, and the answers are ones that I wrote.

### Async

#### Debounce

```
function debounce(callback, interval) {
  let timer,
    readyToCall = true;

  /**
   *
   * @returns callback(), or "undefined" depending on if interval ms have ellapsed since last call to debouncedFunction
   */
  function debouncedFunction() {
    if (readyToCall) {
      readyToCall = false;

      timer = setTimeout(() => {
        readyToCall = true;
      }, interval);

      return callback();
    } else {
      // when debouncedFunction is not ready to be called,the timer running from the previous call should be reset—making it "debouced three seconds from every call", instead of "debounded three seconds from every successful call"
      clearTimeout(timer);

      timer = setTimeout(() => {
        readyToCall = true;
      }, interval);

      return "unsucessful";
    }
  }

  return debouncedFunction;
}

function sayHi() {
  return "hi";
}

const debouncedSayHi = debounce(sayHi, 3000);

/* tests */

console.log(debouncedSayHi()); // -> 'hi'

setTimeout(() => {
  console.log(debouncedSayHi());
}, 2000); // -> undefined

setTimeout(() => {
  console.log(debouncedSayHi());
}, 4000); // -> undefined

setTimeout(() => {
  console.log(debouncedSayHi());
}, 8000); // -> 'hi'

// ?? using iterm to run file, there is a second pause in between when cb for last setTimeout? I would expect it to just cut out right there

```

#### Second Clock

```
class SecondClock {
  constructor(cb) {
    this.cb = cb;
    this.secondsHand = 0;
    this.clock = undefined;
  }
  start() {
    this.clock = setInterval(() => {
      this.cb(++this.secondsHand);
    }, 1000);
  }
  reset() {
    clearInterval(this.clock);
  }
}

//tests

const clock = new SecondClock((val) => {
  console.log(val);
});

console.log("Started Clock.");
clock.start();

setTimeout(() => {
  clock.reset();
  console.log("Stopped Clock after 6 seconds.");
}, 6000);
```
